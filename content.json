{"pages":[{"title":"about","text":"","link":"/about/"}],"posts":[{"title":"CF1304A Two Rabbits","text":"A. Two Rabbits原题传送门 Problem Restatement两个兔子以恒定速度相向而行，求相遇时间？若无法在整时间相遇，输出$-1$ Solution相遇问题，距离除以总速度为时间，看时间是否为整数即可。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;void solve(){ int x,y,a,b; scanf(\"%d %d %d %d\", &amp;x, &amp;y, &amp;a, &amp;b); if((y-x)%(a+b)==0) printf(\"%d\\n\", (y-x)/(a+b)); else printf(\"-1\\n\");}int main(){ int T=1; scanf(\"%d\", &amp;T); while(T--){ solve(); } return 0;}","link":"/Codeforces/Round-620-Div-2/CF1304A/"},{"title":"CF1304B Longest Palindrome","text":"B. Longest Palindrome原题传送门 Problem Restatement给出n个，长度为m的字符串。$(1≤𝑛≤100,1≤m≤50) $ 用部分或全部字符串，在一定的顺序拼接下，拼出最长的回文串。 Solution数据小，直接配对即可。 对于每个串寻找是否存在其共轭串（即一正一反），若存在则放置在串两头。 否则，看是否该串本就是回文，若是则放置中间。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;bool ispair(char *s1,char *s2){ for(int i=0;i&lt;m;i++){ if(s1[i]!=s2[m-i-1]) return 0; } return 1;}bool ispalindrome(char *s1){ for(int i=0;i&lt;m;i++){ if(s1[i]!=s1[m-i-1]) return 0; } return 1;}char s[105][105];bool flag[105];list&lt;int&gt; li;void solve(){ scanf(\"%d %d\", &amp;n, &amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%s\", s[i]); memset(flag+1,0,n*sizeof(flag[0])); li.clear(); int mid=0; for(int i=1;i&lt;=n;i++){ if(flag[i]) continue; for(int j=i+1;j&lt;=n;j++){ if(flag[j]) continue; if(ispair(s[i],s[j])){ flag[i]=flag[j]=1; li.push_front(i); li.push_back(j); break; } } if(!flag[i] &amp;&amp; !mid){ if(ispalindrome(s[i])) mid=i; } } if(mid) printf(\"%lu\\n\", m*li.size()+m); else printf(\"%lu\\n\", m*li.size()); if(li.size()==0 &amp;&amp; mid){ printf(\"%s\\n\", s[mid]); } else{ int cnt=0; for(auto t:li){ cnt++; printf(\"%s\", s[t]); if(cnt==li.size()/2) printf(\"%s\", s[mid]); } }}int main(){ int T=1; // scanf(\"%d\", &amp;T); while(T--){ solve(); } return 0;}","link":"/Codeforces/Round-620-Div-2/CF1304B/"},{"title":"CF1304C Air Conditioner","text":"C. Air Conditioner原题传送门 Problem RestatementGildong的餐厅每单位时间最多上下调整$1$单位温度。 对于某些时刻，总共给出$n$个区间，问是否可以使得每一时刻的温度保持在这些区间里面。 $(1≤𝑛≤100)$ Solution有点像“接元宝”那一类的题。不过这题只需要判断是否可以，而不需要找到最多能保证多少个。那么问题就很简单了。 抛开限制区间思考，从初始温度$m$开始，经过$1$单位时间，其实就相当于可以存在的温度变成一个区间$[m-1,m+1]$。以此类推我们可以求出来，无“限制区间”情况下，任意时刻的可调节温度区间。 讨论限制区间时，首先，如果能保持温度在限制区间里面，那么同一时刻的多个区间必须有一个公共区间或者公共点。所以我们只需要对这个公共区间/点进行讨论即可。所以我们可以认定，同一时刻只有一个限制区间。 限制区间本身已经排好序，所以我们只需要按照时间顺序，合并同一时刻区间，然后按顺序判断是否任一时刻可调节温度区间与限制区间是否有重叠区间即可，同时也合并区间。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,tl,tr;int ti[105],l[105],r[105];void solve(){ scanf(\"%d %d\", &amp;n, &amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d %d %d\", &amp;ti[i], &amp;l[i], &amp;r[i]); tl=tr=m; ti[0]=0; for(int i=1,j=1;i&lt;=n;i=j){ tl-=ti[i]-ti[i-1], tr+=ti[i]-ti[i-1]; tl=max(tl,l[i]), tr=min(tr,r[i]); for(j=i+1;j&lt;=n &amp;&amp; ti[j]==ti[j-1];j++){ tl=max(tl,l[j]); tr=min(tr,r[j]); } if(tl&gt;tr){ printf(\"NO\\n\"); return; } } printf(\"YES\\n\");}int main(){ int T=1; scanf(\"%d\", &amp;T); while(T--){ solve(); } return 0;}","link":"/Codeforces/Round-620-Div-2/CF1304C/"},{"title":"CF1304D Shortest and Longest LIS","text":"D. Shortest and Longest LIS原题传送门 Problem Restatement给出一个序列相邻的大小关系，构造相应长度满足大小关系的排列，使得最长上升子序列最短或最长。 Solution考虑到给出的是相邻的递增递减，我们会发现序列是由一段上坡一段下坡类似组合而成。而上坡的地方肯定是最长上升子序列。 定义：坑 = 一个下坡（或没有）+一个上坡。 所以我们可以很容易得出最短的最长上升子序列，最短为其中最长的“上坡”。那么我们只需要保证这些上坡不会被前面和后面续上即可。我们实际构造采取贪心，从最左边的坑开始从大到小填数即可。 同理，最长的最长上升子序列，即让所有的上坡都续上，可以证明续上最多可以为（上坡的元素个数之和 - 上坡的个数 + 1）。同样，贪心构造即可，从左边开始，下坡倒着填，上坡顺着填。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;int n,m,a[MAXN];char s[MAXN];void solve(){ int cnt,rcnt; scanf(\"%d\", &amp;n); scanf(\"%s\", s); memset(a,0,n*sizeof(a[0])); rcnt=n; for(int i=0,j,k;i&lt;=n-1;i=j+1){ while(i&lt;=n-2 &amp;&amp; s[i]=='&gt;') a[i++]=rcnt--; for(j=i;j&lt;=n-2 &amp;&amp; s[j]=='&lt;';j++); for(k=j;k&gt;=i;k--) a[k]=rcnt--; } for(int i=0;i&lt;n;i++) printf(\"%d \", a[i]); puts(\"\"); memset(a,0,n*sizeof(a[0])); cnt=1,rcnt=n; if(s[n-2]=='&lt;') a[n-1]=rcnt--; for(int i=0;i&lt;=n-2;i++){ if(s[i]=='&lt;') a[i]=cnt++; else a[i]=rcnt--; } if(s[n-2]=='&gt;') a[n-1]=cnt; for(int i=0;i&lt;n;i++) printf(\"%d \", a[i]); puts(\"\");}int main(){ int T=1; scanf(\"%d\", &amp;T); while(T--){ solve(); } return 0;}","link":"/Codeforces/Round-620-Div-2/CF1304D/"},{"title":"CF1304E 1-Trees and Queries","text":"E. 1-Trees and Queries原题传送门 Problem Restatement给出一个$n$个节点的树，每次询问，连结$x$与$y$节点，问$a$到$b$节点是否存在一条路径，使得长度为$k$（点和边 可重复走）。 $( 3 \\le n \\le 10^5, 1 \\le q \\le 10^5)$ Solution如果没连结$x$和$y$节点，则$a$到$b$之间的最短路是唯一的，而且由于树没有环，所以在最短路的基础上，只能两个节点之间来回“蹭”（蹭就是走到终点之后，与相邻两个点来回走），所以如果求的最短路为$\\text{dist}(a,b)$，那么唯有当$\\text{dist}(a,b)\\leq k$，而且$2|k-\\text{dist}(a,b)$时，才可以成立。 考虑到目前连结了$x,y$，还是考虑$a$到$b$的最短路。我们可以分出3种情况。 1、不经过$\\text {edge}(x,y)$的最短路。即$\\text{dist}(a,b)$。 2、先从$a$到$x$，经过$\\text {edge}(x,y)$，然后从$y$到$b$。即$\\text{dist}(a,x)+1+\\text{dist}(y,b)$。 3、先从$b$到$x$，经过$\\text {edge}(x,y)$，然后从$y$到$a$。即$\\text{dist}(b,x)+1+\\text{dist}(y,a)$。 可以证明最短路一定在这三种情况之中，而且任何的路都是从这三条路之后重复“蹭”出去的。 （这里证明我没有想到简易证明，倒是可以通过分类讨论$\\text {edge}(x,y)$的位置，比较繁琐。另，证明中其实成环之和的讨论比较特别，要用到奇偶分析。这里留给读者当课后习题。） 总之，如果不能被这三种情况“蹭”出来，那么就是无法构造的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXLN 20using namespace std;struct edge{ int to,next;}e[MAXN&lt;&lt;1];int tot,head[MAXN];void add(int x,int y){ tot++; e[tot].to=y; e[tot].next=head[x]; head[x]=tot;}int dep[MAXN],lgd[MAXN],st[MAXN][MAXLN];void dfs(int cur,int fa){ dep[cur]=dep[fa]+1; st[cur][0]=fa; for(lgd[cur]=1;(1&lt;&lt;lgd[cur])&lt;=dep[cur];lgd[cur]++) st[cur][lgd[cur]]=st[st[cur][lgd[cur]-1]][lgd[cur]-1]; for(int p=head[cur];p;p=e[p].next){ if(e[p].to==fa) continue; dfs(e[p].to,cur); }}int lca(int x,int y){ if(dep[x]&lt;dep[y]) swap(x,y); for(int i=0;dep[x]-dep[y];i++) if((dep[x]-dep[y])&amp;(1&lt;&lt;i)) x=st[x][i]; if(x==y) return x; for(int i=lgd[x];i&gt;=0;i--) if(st[x][i]!=st[y][i]) x=st[x][i], y=st[y][i]; return st[x][0];}void solve(){ int n,q; scanf(\"%d\", &amp;n); tot=0; memset(head+1,0,n*sizeof(head[0])); for(int i=1;i&lt;n;i++){ int f,g; scanf(\"%d %d\", &amp;f, &amp;g); add(f,g); add(g,f); } dep[0]=0; dfs(1,0); scanf(\"%d\", &amp;q); for(int i=1;i&lt;=q;i++){ int x,y,a,b,k,ax,ay,ab,bx,by; scanf(\"%d %d %d %d %d\", &amp;x, &amp;y, &amp;a, &amp;b, &amp;k); ab=dep[a]+dep[b]-2*dep[lca(a,b)]; if(ab&lt;=k &amp;&amp; ((ab-k)&amp;1)==0){ printf(\"YES\\n\"); continue; } ax=dep[a]+dep[x]-2*dep[lca(a,x)]; by=dep[b]+dep[y]-2*dep[lca(b,y)]; if(ax+by+1&lt;=k &amp;&amp; ((ax+by+1-k)&amp;1)==0){ printf(\"YES\\n\"); continue; } ay=dep[a]+dep[y]-2*dep[lca(a,y)]; bx=dep[b]+dep[x]-2*dep[lca(b,x)]; if(ay+bx+1&lt;=k &amp;&amp; ((ay+bx+1-k)&amp;1)==0){ printf(\"YES\\n\"); continue; } printf(\"NO\\n\"); }}int main(){ int T=1; // scanf(\"%d\", &amp;T); while(T--){ solve(); } return 0;}","link":"/Codeforces/Round-620-Div-2/CF1304E/"}],"tags":[{"name":"签到题","slug":"签到题","link":"/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/"},{"name":"最近公共祖先 Lowest Common Ancestors","slug":"最近公共祖先-Lowest-Common-Ancestors","link":"/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-Lowest-Common-Ancestors/"},{"name":"倍增 Doubling","slug":"倍增-Doubling","link":"/tags/%E5%80%8D%E5%A2%9E-Doubling/"},{"name":"贪心 Greedy","slug":"贪心-Greedy","link":"/tags/%E8%B4%AA%E5%BF%83-Greedy/"}],"categories":[{"name":"Codeforces","slug":"Codeforces","link":"/categories/Codeforces/"},{"name":"Round 620 (Div. 2)","slug":"Codeforces/Round-620-Div-2","link":"/categories/Codeforces/Round-620-Div-2/"}]}